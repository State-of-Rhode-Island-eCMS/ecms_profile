<?php

/**
 * @file
 * ecms_base.install
 */

declare(strict_types=1);

/**
 * @file
 * Install, update and uninstall functions for the ecms_base profile.
 */

use Drupal\Core\Batch\BatchBuilder;
use Drupal\Core\Recipe\Recipe;
use Drupal\Core\Recipe\RecipeRunner;
use Drupal\shortcut\Entity\Shortcut;
use Drupal\simple_oauth\Entity\Oauth2ScopeEntityInterface;
use Drupal\user\Entity\User;
use Drupal\user\RoleInterface;

/**
 * Implements hook_install().
 *
 * Perform actions to set up the site for this profile.
 *
 * @see system_install()
 */
function ecms_base_install() {
  // Assign user 1 the "drupal_admin" role.
  $user = User::load(1);
  $user->roles[] = 'drupal_admin';
  $user->save();

  // We install some menu links, so we have to rebuild the router, to ensure the
  // menu links are valid.
  \Drupal::service('router.builder')->rebuildIfNeeded();

  // Populate the default shortcut set.
  $shortcut = Shortcut::create([
    'shortcut_set' => 'default',
    'title' => t('Add content'),
    'weight' => -20,
    'link' => ['uri' => 'internal:/node/add'],
  ]);
  $shortcut->save();

  $shortcut = Shortcut::create([
    'shortcut_set' => 'default',
    'title' => t('All content'),
    'weight' => -19,
    'link' => ['uri' => 'internal:/admin/content'],
  ]);

  $shortcut->save();

  // Install the memcache module.
  $modules_to_install = [
    'memcache',
  ];

  \Drupal::service('module_installer')->install($modules_to_install);

  // Set the system site email address.
  /** @var \Drupal\Core\Config\ConfigFactoryInterface $configFactory */
  $configFactory = \Drupal::service('config.factory');
  $config = $configFactory->getEditable('system.site');
  $config->set('mail', 'ecms@notification.ri.gov');
  $config->save();

}

/**
 * Implements hook_install_tasks().
 */
function ecms_base_install_tasks(): array {
  $tasks = [];

  // Add the task to install the ecms_base module.
  $tasks['ecms_base_apply_workflows'] = [
    'display_name' => t('Apply workflows to all content types.'),
    'type' => 'module',
    'run' => INSTALL_TASK_RUN_IF_NOT_COMPLETED,
    'function' => 'ecms_base_apply_workflows',
  ];

  // Apply default recipes.
  $tasks['ecms_base_apply_default_recipes'] = [
    'display_name' => t('Apply recipes to the installation profile.'),
    'type' => 'batch',
    'run' => INSTALL_TASK_RUN_IF_NOT_COMPLETED,
  ];

  return $tasks;
}

/**
 * Installation task function to apply the base recipes on profile installation.
 */
function ecms_base_apply_default_recipes(): array {
  $recipesToApply = [
    'ecms_gtranslate',
    'ecms_security',
    'ecms_webform',
    'ecms_acquia',
  ];
  $operations = ecms_base_apply_recipes($recipesToApply, FALSE);
  return $operations;
}

/**
 * A reusable function to apply Drupal recipes to the codebase.
 *
 * @param array $recipes
 *   Array of recipe names that should be installed.
 * @param bool $startBatch
 *   Whether to start the batch or return the batch operations as an array.
 *
 * @return array|null
 *   The
 */
function ecms_base_apply_recipes(
  array $recipes,
  bool $startBatch = TRUE,
): ?array {
  $profilePath = \Drupal::service('extension.list.profile')->getPath('ecms_base');
  // Batch the recipe installation.
  $batch = new BatchBuilder();
  foreach ($recipes as $recipeName) {
    $path = sprintf('%s/recipes/%s', $profilePath, $recipeName);
    $recipe = Recipe::createFromDirectory($path);
    foreach (RecipeRunner::toBatchOperations($recipe) as $operation) {
      $batch->addOperation(...$operation);
    }
  }

  $operations = $batch->toArray();
  // Finally, to kick off the job:
  if ($startBatch) {
    batch_set($batch->toArray());
  }

  return $operations;
}

/**
 * Apply the workflows to all content types after the full installation.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 * @throws \Drupal\Core\Entity\EntityStorageException
 */
function ecms_base_apply_workflows() {
  // Call the workflow service to update configuration.
  \Drupal::service('ecms_workflow.bundle_create')
    ->assignWorkflowToActiveTypes();

  // Add correct permissions for the nodes/taxonomies.
  /** @var \Drupal\ecms_workflow\EcmsWorkflowBundleCreate $workflowBundleCreate */
  $workflowBundleCreate = \Drupal::service('ecms_workflow.bundle_create');

  /** @var \Drupal\Core\Entity\EntityTypeBundleInfoInterface $bundleInfo */
  $bundleInfo = \Drupal::service('entity_type.bundle.info');

  $nodes = $bundleInfo->getBundleInfo('node');

  // Guard again an empty array of nodes.
  if (!empty($nodes)) {
    // Add the correct workflow to the node types.
    foreach (array_keys($nodes) as $type) {
      $workflowBundleCreate->addContentTypeToWorkflow($type);
    }
  }

  // Set the permissions for all enabled taxonomy bundles.
  $taxonomies = $bundleInfo->getBundleInfo('taxonomy_term');

  // Guard against empty taxonomies.
  if (!empty($taxonomies)) {
    // Add the correct permissions for the taxonomy types.
    foreach (array_keys($taxonomies) as $taxonomy) {
      $workflowBundleCreate->addTaxonomyTypePermissions($taxonomy);
    }
  }
}

/**
 * Apply the ecms_acquia recipe after the profile change.
 */
function ecms_base_update_11201() {
  $recipes = [
    'ecms_acquia',
  ];

  ecms_base_apply_recipes($recipes);
}

/**
 * Apply missing configuration values.
 */
function ecms_base_update_11202() {
  // Manually set the publish content settings as they were installed
  // incorrectly and missing values.
  $config = \Drupal::configFactory()->getEditable('publishcontent.settings');
  $config->set('publish_text_value', 'Publish');
  $config->set('unpublish_text_value', 'Unpublish');
  $config->set('ui_localtask', 1);
  $config->set('ui_checkbox', 0);
  $config->save(TRUE);
}

/**
 * Uninstall google_translator module and remove related configurations.
 *
 * Runs with 2.0.1.
 */
function ecms_base_update_11203(array &$sandbox): void {
  // Disable existing modules.
  $modules_to_uninstall = [
    'google_translator',
  ];

  // Make sure necessary modules are uninstalled.
  \Drupal::service('module_installer')->uninstall($modules_to_uninstall);

  // Remove the language switcher block if it exists.
  $configToDelete = [
    'block.block.ecms_ecmstranslatorgoogletranslator',
    'block.block.languageswitcher',
    'block.block.googletranslator',
  ];
  /** @var \Drupal\Core\Config\StorageInterface $active_storage */
  $active_storage = \Drupal::service('config.storage');
  foreach ($configToDelete as $config) {
    if ($active_storage->exists($config)) {
      $active_storage->delete($config);
    }
  }

  // Install new modules.
  $recipes = [
    'ecms_gtranslate',
  ];

  ecms_base_apply_recipes($recipes);
}

/**
 * Remove missing jQuery UI modules from core.extension configuration.
 *
 * Runs with 2.0.1.
 */
function ecms_base_update_11204(): void {
  $config = \Drupal::configFactory()->getEditable('core.extension');
  $modules = $config->get('module');

  $missing_modules = [
    'jquery_ui_datepicker',
    'jquery_ui_slider',
    'jquery_ui_touch_punch',
    'menu_force',
  ];

  $changed = FALSE;
  foreach ($missing_modules as $module) {
    if (isset($modules[$module])) {
      unset($modules[$module]);
      $changed = TRUE;
    }
  }

  if ($changed) {
    $config->set('module', $modules);
    $config->save(TRUE);
  }

  // Remove schema entries from key/value storage.
  $key_value = \Drupal::keyValue('system.schema');
  foreach ($missing_modules as $module) {
    if ($key_value->has($module)) {
      $key_value->delete($module);
      \Drupal::logger('ecms_base')->info('Removed schema entry for missing module: @module', [
        '@module' => $module,
      ]);
    }
  }
}

/**
 * Delete all consumer entities.
 *
 * Runs with 2.0.1.
 */
function ecms_base_update_11205(): void {
  try {
    $entityTypeManager = \Drupal::entityTypeManager();
    $storage = $entityTypeManager->getStorage('consumer');
    $entities = $storage->loadMultiple();
    if (!empty($entities)) {
      $storage->delete($entities);
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('ecms_base')
      ->error('Failed to delete consumer entities: @message', ['@message' => $e->getMessage()]);
  }
}

/**
 * Apply the ecms_api_publisher recipe if the module is installed.
 *
 * Runs with 2.0.1.
 */
function ecms_base_update_11206(): void {
  $recipes = [];
  $moduleHandler = \Drupal::moduleHandler();
  $entityTypeManager = \Drupal::entityTypeManager();

  // Check if the ecms_api_publisher module is enabled.
  if ($moduleHandler->moduleExists('ecms_api_publisher')) {
    $userStorage = $entityTypeManager->getStorage('user');
    $publisher = $userStorage->loadByProperties(['name' => 'ecms_api_publisher']);
    if (!empty($publisher)) {
      // Block the publisher account and rename the email address.
      // This will allow the recipe to run successfully.
      $account = reset($publisher);
      $email = $account->getEmail();
      $account->setUsername('ecms_api_publisher_legacy');
      $account->setEmail(str_replace('@', '_legacy@', $email));
      $account->block();
      $account->save();
    }

    // Delete the ecms_api_publisher role if it exists.
    $role_storage = $entityTypeManager->getStorage('user_role');
    $role = $role_storage->load('ecms_api_publisher');
    if ($role instanceof RoleInterface) {
      $role->delete();
    }

    // Delete the scope if it exists.
    $scope_storage = $entityTypeManager->getStorage('oauth2_scope');
    $scope = $scope_storage->load('ecms_api_publisher');
    if ($scope instanceof Oauth2ScopeEntityInterface) {
      $scope->delete();
    }

    $recipes[] = 'ecms_api_publisher';
  }

  // Apply recipes for the modules that were uninstalled.
  if (!empty($recipes)) {
    ecms_base_apply_recipes($recipes);
  }
}

/**
 * Apply the ecms_api_recipient recipe if the module is installed.
 *
 * Runs with 2.0.1.
 */
function ecms_base_update_11207(): void {
  $recipes = [];
  $moduleHandler = \Drupal::moduleHandler();
  $entityTypeManager = \Drupal::entityTypeManager();

  // Check if the ecms_api_publisher module is enabled.
  if ($moduleHandler->moduleExists('ecms_api_recipient')) {
    $userStorage = $entityTypeManager->getStorage('user');
    $recipient = $userStorage->loadByProperties(['name' => 'ecms_api_recipient']);
    if (!empty($recipient)) {
      // Block the recipient account and rename the email address.
      // This will allow the recipe to run successfully.
      $account = reset($recipient);
      $email = $account->getEmail();
      $account->setUsername('ecms_api_recipient_legacy');
      $account->setEmail(str_replace('@', '_legacy@', $email));
      $account->block();
      $account->save();
    }

    // Delete the ecms_api_publisher role if it exists.
    $role_storage = $entityTypeManager->getStorage('user_role');
    $role = $role_storage->load('ecms_api_recipient');
    if ($role instanceof RoleInterface) {
      $role->delete();
    }

    // Delete the scope if it exists.
    $scope_storage = $entityTypeManager->getStorage('oauth2_scope');
    $scope = $scope_storage->load('ecms_api_recipient');
    if ($scope instanceof Oauth2ScopeEntityInterface) {
      $scope->delete();
    }

    $recipes[] = 'ecms_api_recipient';
  }

  // Apply recipes for the modules that were uninstalled.
  if (!empty($recipes)) {
    ecms_base_apply_recipes($recipes);
  }
}

/**
 * Install the ecms_asset_injector module for dark mode CSS handling.
 *
 * Runs with 2.0.1.
 */
function ecms_base_update_11208(): void {
  $modules_to_install = [
    'ecms_asset_injector',
  ];

  \Drupal::service('module_installer')->install($modules_to_install);
}
/**
 * Update any existing CSS assets to include dark mode CSS handling.
 *
 * Runs with 2.0.1.
 */
function ecms_base_update_11209(array &$sandbox): void {
  // Load all CSS Injector entities storage.
  $storage = \Drupal::entityTypeManager()->getStorage('asset_injector_css');

  if (!isset($sandbox['total'])) {
    $ids = $storage->getQuery()->accessCheck(FALSE)->execute();
    $sandbox['total'] = count($ids);
    $sandbox['ids'] = array_values($ids);
    $sandbox['current'] = 0;
    $sandbox['processed_count'] = 0;
    $sandbox['failed_count'] = 0;

    if (empty($sandbox['ids'])) {
      $sandbox['#finished'] = 1;
      \Drupal::messenger()->addStatus(t('eCMS Asset Injector installed. No existing CSS assets to process.'));
      return;
    }
  }

  $limit = 10;
  $ids_to_process = array_slice($sandbox['ids'], $sandbox['current'], $limit);
  $assets = $storage->loadMultiple($ids_to_process);

  foreach ($assets as $asset) {
    try {
      // Resave the entity to trigger preSave() and generate processedCode.
      $asset->save();
      $sandbox['processed_count']++;
      \Drupal::logger('ecms_asset_injector')->info('Processed CSS asset: @label (@id)', [
        '@label' => $asset->label(),
        '@id' => $asset->id(),
      ]);
    }
    catch (\Exception $e) {
      $sandbox['failed_count']++;
      \Drupal::logger('ecms_asset_injector')->error('Failed to process CSS asset: @label (@id). Error: @error', [
        '@label' => $asset->label(),
        '@id' => $asset->id(),
        '@error' => $e->getMessage(),
      ]);
    }
  }

  $sandbox['current'] += count($ids_to_process);
  $sandbox['#finished'] = empty($sandbox['total']) ? 1 : ($sandbox['current'] / $sandbox['total']);

  // Display a summary message.
  if ($sandbox['#finished'] >= 1) {
    if ($sandbox['processed_count'] > 0) {
      \Drupal::messenger()->addStatus(t('eCMS Asset Injector installed and processed @count CSS asset(s) with dark mode handling.', [
        '@count' => $sandbox['processed_count'],
      ]));
    }

    if ($sandbox['failed_count'] > 0) {
      \Drupal::messenger()->addWarning(t('Failed to process @count CSS asset(s). Check logs for details.', [
        '@count' => $sandbox['failed_count'],
      ]));
    }
  }
}
